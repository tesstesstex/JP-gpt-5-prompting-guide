# JP-gpt-5-prompting-guide
[元記事](https://cookbook.openai.com/examples/gpt-5/gpt-5_prompting_guide)

# 本文翻訳
当社の最新フラッグシップモデルであるGPT-5は、エージェント的なタスク遂行能力、コーディング、基礎知能、そして制御性において、大きな飛躍を遂げています。

GPT-5は幅広い分野で「初期設定のまま」でも優れた性能を発揮すると確信していますが、このガイドでは、私たちがモデルのトレーニングや実世界のタスクへの応用経験から得た、出力品質を最大化するためのプロンプトのヒントについて解説します。ここでは、エージェント的なタスク遂行能力の向上、指示への忠実性の確保、新しいAPI機能の活用、そしてフロントエンドおよびソフトウェアエンジニアリングタスクにおけるコーディングの最適化といったコンセプトについて、AIコードエディタ「Cursor」がGPT-5で行ったプロンプトチューニングから得られた重要な知見も交えながら説明します。

これらのベストプラクティスを適用し、可能な限り当社の標準ツールを採用することで、私たちは大きな成果を上げてきました。このガイドが、私たちが開発したプロンプト最適化ツールと共に、皆様がGPT-5を利用し始めるための出発点となることを願っています。しかし、いつものことながら、プロンプト作成は画一的なものではないことを忘れないでください。ご自身の問題に最適な解決策を見つけるために、ここで提供される基礎を元に、実験と試行錯誤を重ねていただくことを推奨します。

エージェント的ワークフローの予測可能性
私たちは開発者を念頭に置いてGPT-5をトレーニングしました。エージェント的なアプリケーションに最適な基盤モデルとなるよう、ツール呼び出し、指示追従性、そして長文脈理解の向上に注力しています。

GPT-5をエージェント的フローやツール呼び出しフローに採用される場合は、Responses APIへのアップグレードを推奨します。このAPIでは、ツール呼び出し間で思考プロセスが維持されるため、より効率的で知的な出力につながります。

エージェントの積極性を制御する
エージェントを制御する仕組みは、その制御の度合いが多岐にわたります。意思決定の大部分を基盤モデルに委任するシステムもあれば、厳格なプログラム的論理分岐でモデルを厳しく管理するシステムもあります。GPT-5は、曖昧な状況下で高レベルの意思決定を行うことから、的を絞った明確なタスクを処理することまで、このスペクトラム上のあらゆるレベルで動作するようにトレーニングされています。このセクションでは、GPT-5のエージェントとしての積極性、つまり、その積極性と明確な指示を待つ姿勢とのバランスを最適に調整する方法について説明します。

積極性を抑えるためのプロンプト
GPT-5は、正しい答えを生成できるようにするため、デフォルトではエージェント環境でコンテキストを収集する際に徹底的かつ包括的に動作します。本筋から逸れたツール呼び出しを制限し、最終的な回答に至るまでの遅延を最小限に抑えるなど、GPT-5のエージェントとしての振る舞いの範囲を狭めるには、以下の方法をお試しください。

reasoning_effortを低く設定します。これにより探索の深さは浅くなりますが、効率と遅延は改善されます。多くのワークフローは、reasoning_effortが中程度、あるいは低くても一貫した結果で達成可能です。

モデルに問題空間をどのように探索してほしいかについて、プロンプトで明確な基準を定義します。これにより、モデルが過剰なアイデアを探索・推論する必要がなくなります。

<context_gathering>
目標: 迅速に十分なコンテキストを得る。発見プロセスを並列化し、行動可能になり次第停止する。
手法:
- 広く開始し、その後、焦点を絞ったサブクエリに展開する。
- 並行して多様なクエリを実行し、クエリごとに上位のヒットを読む。パスの重複を排除してキャッシュし、クエリを繰り返さない。
- コンテキストの過剰な検索を避ける。必要であれば、対象を絞った検索を1つの並列バッチで実行する。
早期停止基準:
- 変更すべき正確なコンテンツを特定できる。
- 上位のヒットが1つの領域/パスに収束する（約70%）。
一度だけエスカレーション:
- シグナルが競合したり、範囲が曖昧な場合は、洗練された並列バッチを1回実行してから続行する。
深さ:
- 変更するシンボル、またはその契約に依存するシンボルのみを追跡する。不要な限り推移的な展開は避ける。
ループ:
- バッチ検索 → 最小限の計画 → タスク完了。
- 検証が失敗した場合、または新たな不明点が現れた場合にのみ再検索する。検索よりも行動を優先する。
</context_gathering>
最大限に指示的にしたい場合は、以下のようにツール呼び出しの固定予算を設定することもできます。この予算は、希望する検索の深さに応じて柔軟に設定できます。

<context_gathering>
- 検索の深さ: 非常に浅い
- たとえ完全には正しくない可能性があっても、できるだけ早く正解を提供することを強く優先する。
- 通常、これはツール呼び出しが絶対最大2回であることを意味する。
- 調査にもっと時間が必要だと判断した場合は、最新の調査結果と未解決の質問をユーザーに報告する。ユーザーが承認すれば続行できる。
</context_gathering>
中核となるコンテキスト収集の振る舞いを制限する際には、モデルに明確な「緊急避難口」（エスケープハッチ）を設けることが有効です。これにより、より短いコンテキスト収集ステップで満足しやすくなります。通常、これは上記の例の「たとえ完全には正しくない可能性があっても」のように、モデルが不確実な状況下でも処理を続行できるような一文の形で与えられます。

積極性を高めるためのプロンプト
一方で、モデルの自律性を促進し、ツール呼び出しの持続性を高め、確認のための質問やユーザーへの処理の差し戻しを減らしたい場合は、reasoning_effortを高く設定し、持続性と徹底的なタスク完了を促すために、以下のようなプロンプトを使用することをお勧めします。

<persistence>
- あなたはエージェントです。ユーザーのクエリが完全に解決されるまで処理を続け、その後にあなたのターンを終了してユーザーに応答を返してください。
- 問題が解決したと確信できた場合にのみ、あなたのターンを終了してください。
- 不確実な状況に遭遇しても、決して停止したりユーザーに処理を戻したりしないでください。最も合理的なアプローチを調査または推論し、処理を続けてください。
- 後でいつでも調整できるため、人間に仮定の確認や明確化を求めないでください。最も合理的な仮定を決定し、それに基づいて処理を進め、行動が完了した後にユーザーが参照できるようにその仮定を記録してください。
</persistence>
一般的に、エージェントタスクの停止条件を明確に述べ、安全なアクションと危険なアクションの概要を示し、モデルがユーザーに処理を差し戻すことが許容される状況（もしあるならば）を定義することが有効です。例えば、ショッピング用の一連のツールでは、チェックアウトツールや支払いツールはユーザーの確認を必要とする不確実性のしきい値を明示的に低く設定すべきですが、検索ツールはそのしきい値を非常に高く設定すべきです。同様に、コーディングのセットアップでは、ファイル削除ツールはgrep検索ツールよりもはるかに低いしきい値を持つべきです。

ツールの前置き (Tool preambles)
ユーザーが監視するエージェントの一連の動作において、モデルがツール呼び出しで何を行い、なぜそうしているのかを断続的に報告することで、はるかに優れた対話的なユーザー体験が提供できると私たちは認識しています。処理が長くなるほど、これらの報告がもたらす差は大きくなります。この目的のため、GPT-5は「ツールの前置き」メッセージを介して、明確な事前の計画と一貫した進捗報告を提供するようにトレーニングされています。

プロンプトを通じて、ツールの前置きの頻度、スタイル、内容を、個々のツール呼び出しに関する詳細な説明から簡潔な事前計画まで、自在に制御できます。以下は、質の高い前置きのためのプロンプトの例です。

<tool_preambles>
- ツールを呼び出す前に、必ずユーザーの目標をフレンドリー、明確、かつ簡潔な言葉で言い換えることから始めてください。
- 次に、実行する各論理ステップを詳述した構造化された計画の概要をただちに示してください。
- ファイル編集を実行する際は、各ステップを簡潔かつ順を追って説明し、進捗を明確に示してください。
- 最後に、完了した作業を事前の計画とは区別して明確に要約してください。
</tool_preambles>
以下は、このようなプロンプトに応じて生成されうるツールの前置きの例です。エージェントの作業が複雑化するにつれて、このような前置きはユーザーが作業内容を把握する能力を劇的に向上させます。

```JSON

"output": [
    {
      "id": "rs_6888f6d0606c819aa8205ecee386963f0e683233d39188e7",
      "type": "reasoning",
      "summary": [
        {
          "type": "summary_text",
          "text": "**天気の応答を決定**\n\nサンフランシスコの天気に関するユーザーの質問に答える必要があります。...."
        },
    },
    {
      "id": "msg_6888f6d83acc819a978b51e772f0a5f40e683233d39188e7",
      "type": "message",
      "status": "completed",
      "content": [
        {
          "type": "output_text",
          "text": "ライブの天気情報サービスでサンフランシスコの現在の気象状況を確認し、お客様の好みに合わせて気温を華氏と摂氏の両方でお伝えします。"
        }
      ],
      "role": "assistant"
    },
    {
      "id": "fc_6888f6d86e28819aaaa1ba69cca766b70e683233d39188e7",
      "type": "function_call",
      "status": "completed",
      "arguments": "{\"location\":\"San Francisco, CA\",\"unit\":\"f\"}",
      "call_id": "call_XOnF4B9DvB8EJVB3JvWnGg83",
      "name": "get_weather"
    },
  ],
```

Reasoning effort（推論の労力）
私たちは、モデルがどれだけ深く思考し、どれだけ積極的にツールを呼び出すかを制御するためのreasoning_effortパラメータを提供しています。デフォルトはmedium（中）ですが、タスクの難易度に応じてこれを上下に調整してください。複雑で複数ステップにわたるタスクには、可能な限り最高の結果を得るために、より高い推論レベルを設定することを推奨します。さらに、明確に分離可能な個別のタスクを、それぞれ1ターンずつ使って複数のエージェントターンに分割した場合に、最高のパフォーマンスが発揮されることが分かっています。

Responses APIによる推論コンテキストの再利用
GPT-5を使用する際には、改善されたエージェント的フローの実現、コスト削減、そしてアプリケーションにおけるトークン使用の効率化のために、Responses APIの使用を強く推奨します。

Chat Completionsの代わりにResponses APIを使用した場合、評価において統計的に有意な改善が見られます。例えば、単にResponses APIに切り替え、後続のリクエストに以前の推論アイテムを引き継ぐためにprevious_response_idを含めるだけで、Tau-Bench Retailのスコアが73.9%から78.2%に向上することが確認されています。これにより、モデルは以前の思考の軌跡（reasoning traces）を参照できるようになり、CoT（Chain-of-Thought）トークンを節約し、各ツール呼び出し後に計画を一から再構築する必要がなくなるため、遅延とパフォーマンスの両方が改善されます。この機能は、ZDR組織を含むすべてのResponses APIユーザーが利用可能です。

コーディング性能の最大化：計画から実行まで
GPT-5は、コーディング能力において全ての最先端モデルをリードしています。大規模なコードベースでのバグ修正、大規模な差分（diff）の取り扱い、複数ファイルにわたるリファクタリングや大規模な新機能の実装が可能です。また、新しいアプリを完全にゼロから実装することにも優れており、フロントエンドとバックエンドの両方の実装に対応しています。このセクションでは、当社のコーディングエージェントをご利用のお客様の本番ユースケースにおいて、プログラミング性能を向上させることが確認されているプロンプトの最適化について説明します。

フロントエンドアプリ開発
GPT-5は、その厳密な実装能力に加え、優れた基本的な美的センスも持ち合わせるようにトレーニングされています。私たちは、GPT-5があらゆる種類のWeb開発フレームワークやパッケージを使用できる能力に自信を持っています。しかし、新しいアプリについては、モデルのフロントエンド能力を最大限に引き出すために、以下のフレームワークやパッケージの使用を推奨します。

フレームワーク: Next.js (TypeScript), React, HTML

スタイリング / UI: Tailwind CSS, shadcn/ui, Radix Themes

アイコン: Material Symbols, Heroicons, Lucide

アニメーション: Motion

フォント: San Serif, Inter, Geist, Mona Sans, IBM Plex Sans, Manrope

ゼロからのアプリ生成
GPT-5は、アプリケーションを一度の指示（ワンショット）で構築することに優れています。このモデルの初期実験において、ユーザーは以下のようなプロンプトを使用することで、GPT-5の徹底した計画能力と自己評価能力を活用し、出力の品質が向上することを発見しました。このプロンプトは、モデルが自ら構築した評価基準（ルーブリック）に照らして繰り返し実行するよう求めるものです。

<self_reflection>
- まず、自信が持てるまで、評価基準（ルーブリック）について時間をかけて考えてください。
- 次に、世界クラスのワンショットWebアプリを構成するあらゆる側面について深く考えてください。その知識を使い、5〜7個のカテゴリを持つ評価基準を作成します。この評価基準を正しく設定することが極めて重要ですが、これをユーザーに見せてはいけません。これはあなた自身の目的のためにのみ使用します。
- 最後に、その評価基準を使って、与えられたプロンプトに対する最善の解決策を内部で考え、繰り返し検討してください。もしあなたの応答が評価基準の全カテゴリで最高点を満たしていない場合は、最初からやり直す必要があることを忘れないでください。
</self_reflection>
コードベースの設計基準に合わせる
既存のアプリで段階的な変更やリファクタリングを実装する際、モデルが生成したコードは既存のスタイルや設計基準に従い、可能な限り自然にコードベースに溶け込むべきです。特別なプロンプトがなくても、GPT-5は（例えばpackage.jsonを読み込んでインストール済みのパッケージを確認するなど）コードベースから参照コンテキストを検索しますが、この振る舞いはプロンプトで指示を与えることでさらに強化できます。その指示とは、エンジニアリング原則、ディレクトリ構造、明示的および暗黙的なベストプラクティスといったコードベースの主要な側面を要約したものです。以下のプロンプトスニペットは、GPT-5用のコード編集ルールを体系化する一例です。ルールの内容は、ご自身の設計の好みに合わせて自由に変更してください！

<code_editing_rules>
<guiding_principles>
- 明確性と再利用性: すべてのコンポーネントとページは、モジュール化され再利用可能であるべきです。繰り返されるUIパターンをコンポーネントに切り出すことで、重複を避けてください。
- 一貫性: ユーザーインターフェースは一貫したデザインシステムに従う必要があります。カラートークン、タイポグラフィ、スペーシング、コンポーネントは統一されなければなりません。
- シンプルさ: 小さく、焦点を絞ったコンポーネントを優先し、スタイリングやロジックにおける不必要な複雑さを避けてください。
- デモ指向: ストリーミング、複数ターンの対話、ツール統合といった機能のデモができるよう、迅速なプロトタイピングが可能な構造にしてください。
- 視覚的な品質: OSSガイドラインで概説されている高い視覚的品質基準（スペーシング、パディング、ホバー状態など）に従ってください。
</guiding_principles>
<frontend_stack_defaults>
- フレームワーク: Next.js (TypeScript)
- スタイリング: TailwindCSS
- UIコンポーネント: shadcn/ui
- アイコン: Lucide
- 状態管理: Zustand
- ディレクトリ構造: 
\`\`\`
/src
 /app
   /api/<route>/route.ts         # APIエンドポイント
   /(pages)                      # ページルート
 /components/                    # UIビルディングブロック
 /hooks/                         # 再利用可能なReactフック
 /lib/                           # ユーティリティ (fetcher, ヘルパー)
 /stores/                        # Zustandストア
 /types/                         # 共有TypeScript型
 /styles/                        # Tailwind設定
\`\`\`
</frontend_stack_defaults>
<ui_ux_best_practices>
- 視覚的階層: 一貫した階層のために、タイポグラフィを4〜5種類のフォントサイズとウェイトに制限してください。キャプションや注釈には `text-xs` を使用し、ヒーローセクションや主要な見出し以外では `text-xl` の使用を避けてください。
- 色の使用: 1色のニュートラルなベースカラー（例: `zinc`）と、最大2色のアクセントカラーを使用してください。
- スペーシングとレイアウト: 視覚的なリズムを保つため、パディングとマージンには常に4の倍数を使用してください。長いコンテンツストリームを扱う場合は、内部スクロールを持つ固定高さのコンテナを使用してください。
- 状態のハンドリング: データ取得中を示すには、スケルトンプレースホルダーまたは `animate-pulse` を使用してください。ホバー時のトランジション（`hover:bg-*`、`hover:shadow-md`）でクリッカブルであることを示してください。
- アクセシビリティ: 適切な場所でセマンティックHTMLとARIAロールを使用してください。アクセシビリティが組み込まれている、ビルド済みのRadix/shadcnコンポーネントを優先して使用してください。
</ui_ux_best_practices>
</code_editing_rules>

本番環境での共同コーディング：CursorによるGPT-5のプロンプトチューニング
AIコードエディタであるCursorに、信頼できるアルファテスターとしてGPT-5をご利用いただけたことを誇りに思います。以下では、Cursorがモデルの能力を最大限に引き出すためにどのようにプロンプトを調整（チューニング）したか、その一端をご紹介します。詳細については、彼らのチームがCursorへのGPT-5の即日統合（day-one integration）を詳述したブログ記事も公開しています: https://cursor.com/blog/gpt-5

システムプロンプトとパラメータチューニング
Cursorのシステムプロンプトは、信頼性の高いツール呼び出しに重点を置き、冗長性と自律的な振る舞いのバランスを取りつつ、ユーザーがカスタム指示を設定できるようにしています。彼らがシステムプロンプトで目指すのは、エージェントが長期間にわたるタスクを比較的自律的にこなし、かつユーザーからの指示にも忠実に従うことです。

当初、チームはモデルが冗長な出力をすることに気づきました。これには、技術的には関連性があるもののユーザーの自然な作業フローを妨げるステータス更新やタスク後の要約がしばしば含まれていました。その一方で、ツール呼び出しで出力されるコードは高品質でしたが、1文字の変数名が多用されるなど、簡潔すぎるために読みにくいことがありました。より良いバランスを求め、彼らはテキスト出力を簡潔にするためにverbosity APIパラメータをlowに設定し、その上で、コーディングツール内でのみ詳細な（冗長な）出力を強く促すようにプロンプトを修正しました。

まず明確さを第一にコードを書いてください。分かりやすい名前、必要な箇所へのコメント、そして簡潔な制御フローを持つ、可読性が高く保守しやすいソリューションを優先します。明示的に要求されない限り、コードゴルフや過度に巧妙なワンライナーは生成しないでください。コードおよびコーディングツールを記述する際は、高い冗長性（high verbosity）を使用してください。

このパラメータとプロンプトの二重活用により、効率的で簡潔なステータス更新や作業要約と、はるかに可読性の高いコード差分（diff）とを組み合わせた、バランスの取れた形式が実現しました。

Cursorはまた、モデルが行動を起こす前に明確化や次のステップをユーザーに確認することがあり、これが長期間のタスクフローにおいて不要な手間を生み出していることにも気づきました。これに対処するため、彼らは利用可能なツールや周囲のコンテキストだけでなく、製品の振る舞いに関するより詳細な情報を含めることで、モデルがより少ない中断と、より大きな自律性をもって長期間のタスクを遂行するよう促せると発見しました。コードの取り消し/拒否やユーザー設定といったCursorの機能の詳細を強調することは、GPT-5がその環境でどのように振る舞うべきかを明確に指定し、曖昧さを減らすのに役立ちました。長期間にわたるタスクにおいて、彼らは以下のプロンプトがパフォーマンスを向上させることを見出しました。

あなたが行うコード編集は、提案された変更としてユーザーに表示されることを認識してください。これは、(a) ユーザーはいつでも拒否できるため、あなたのコード編集は非常に積極的なものであって構わないこと、そして (b) あなたのコードは、適切に記述され、素早くレビューできるものであるべきこと（例：1文字ではなく適切な変数名を使用する）を意味します。コードの変更を伴う次のステップを提案する場合は、計画を進めるかどうかをユーザーに尋ねるのではなく、ユーザーが承認/拒否できるように、それらの変更を積極的に行ってください。一般的に、計画を進めるかどうかをユーザーに尋ねるべきではありません。代わりに、計画を積極的に試み、実装された変更を受け入れるかどうかをユーザーに尋ねるべきです。

Cursorは、以前のモデルで効果的だったプロンプトの一部が、GPT-5の能力を最大限に引き出すためにはチューニングが必要であることに気づきました。以下はその一例です。

<maximize_context_understanding>
情報を収集する際は徹底的に行ってください。返信する前に全体像を完全に把握していることを確認してください。必要に応じて、追加のツール呼び出しや明確化のための質問を使用してください。
...
</maximize_context_understanding>
これは、コンテキストを徹底的に分析するよう促す必要があった旧モデルではうまく機能しましたが、元々コンテキスト収集において内省的かつ積極的であるGPT-5では逆効果であることが分かりました。小規模なタスクでは、内部知識で十分な場合でも、このプロンプトによってモデルが検索を繰り返し呼び出すなど、ツールを過剰に使用することがよくありました。

これを解決するため、彼らはmaximize_という接頭辞を削除し、徹底性に関する言葉遣いを和らげることでプロンプトを洗練させました。この調整された指示により、Cursorチームは、GPT-5が内部知識に頼るべきか外部ツールを利用すべきかについて、より良い判断を下すのを確認しました。これにより、不要なツールの使用なしに高いレベルの自律性が維持され、より効率的で的確な振る舞いにつながりました。Cursorのテストでは、<[instruction]_spec>のような構造化されたXMLスペックを使用することで、プロンプトへの指示遵守が向上し、プロンプト内の他の場所で以前のカテゴリやセクションを明確に参照できるようになったとのことです。

<context_understanding>
...
ユーザーのクエリを部分的に満たす可能性のある編集を行ったが、自信がない場合は、ターンを終了する前に追加の情報を収集するか、より多くのツールを使用してください。
自分で答えを見つけられる場合は、ユーザーに助けを求めないことを優先してください。
</context_understanding>
システムプロンプトが強力なデフォルトの基盤を提供する一方で、ユーザープロンプトは依然として制御性（steerability）のための非常に効果的な手段です。GPT-5は直接的で明確な指示によく応答し、Cursorチームは、構造化され、範囲が限定されたプロンプトが最も信頼性の高い結果をもたらすことを一貫して確認しています。これには、冗長性の制御、主観的なコードスタイルの好み、エッジケースへの感度といった領域が含まれます。Cursorは、ユーザーが独自のカスタムルールを設定できるようにすることが、GPT-5の向上した制御性において特に効果的であり、ユーザーによりカスタマイズされた体験を提供できることを発見しました。

知能と指示追従性の最適化
制御性（ステアリング）
これまでで最も制御性の高いモデルとして、GPT-5は冗長性（verbosity）、トーン、そしてツール呼び出しの振る舞いに関するプロンプトの指示を非常によく受け入れます。

冗長性（Verbosity）
これまでの推論モデルと同様にreasoning_effortを制御できることに加え、GPT-5ではverbosityという新しいAPIパラメータを導入しました。これは、思考の長さとは対照的に、モデルの最終的な回答の長さに影響を与えます。

当社のブログ記事では、このパラメータの背景にある考え方をより詳しく解説していますが、このガイドでは特に次の点を強調します。APIのverbosityパラメータが標準のデフォルト設定である一方、GPT-5は、特定のコンテキストにおいて全体的なデフォルト設定から逸脱させたい場合に、プロンプト内の自然言語による冗長性の上書き指示に応答するようトレーニングされています。前述のCursorの例のように、全体的に低い冗長性（low verbosity）を設定し、その上でコーディングツールに対してのみ高い冗長性（high verbosity）を指定する、というのがそのようなコンテキストの典型的な例です。

指示追従性
GPT-4.1と同様に、GPT-5は極めて高い精度でプロンプトの指示に従います。これにより、あらゆる種類のワークフローに柔軟に組み込むことが可能です。しかし、その慎重な指示追従性のために、矛盾した、あるいは曖昧な指示を含む不適切なプロンプトは、他のモデルよりもGPT-5にとって大きな損害となる可能性があります。なぜなら、GPT-5はランダムに一つの指示を選ぶのではなく、矛盾を解消する方法を探すために推論トークンを消費してしまうからです。

以下に示すのは、GPT-5の推論の軌跡を損ないがちなプロンプトの敵対的な例です。一見すると内部的に一貫しているように見えますが、よく調べると予約スケジュールに関して矛盾した指示が含まれていることが分かります。

「カルテに記録された患者の明確な同意なしに予約を入れない」という指示が、その後の「リスクを減らすための最初のアクションとして、患者に連絡せずに同日の一番早い枠を自動的に割り当てる」という指示と矛盾しています。

プロンプトには「他のいかなるアクションを起こす前にも、必ず患者プロファイルを検索して既存の患者であることを確認する」とありますが、その後に「症状が緊急性が高いことを示す場合は、EMERGENCYとしてエスカレーションし、いかなる予約ステップよりも前に、直ちに911に電話するよう患者に指示する」という矛盾した指示が続きます。

あなたはCareFlow Assistantです。ヘルスケアスタートアップの仮想アシスタントで、優先度と症状に基づいて患者の予約をスケジュールします。あなたの目標は、リクエストをトリアージし、患者を適切なネットワーク内の医療提供者とマッチングさせ、臨床的に最も早く適切な時間枠を予約することです。他のいかなるアクションを起こす前にも、必ず患者プロファイルを検索して既存の患者であることを確認してください。

（修正版） 中核となるエンティティは、患者、医療提供者、予約、優先度レベル（赤、オレンジ、黄、緑）です。症状を優先度にマッピングします：赤は2時間以内、オレンジは24時間以内、黄は3日以内、緑は7日以内。症状が緊急性が高いことを示す場合は、EMERGENCYとしてエスカレーションし、いかなる予約ステップよりも前に、直ちに911に電話するよう患者に指示してください。緊急の場合は検索を行わず、直ちに911のガイダンスを提供することに進んでください。

次の機能を使用してください：schedule-appointment, modify-appointment, waitlist-add, find-provider, lookup-patient, notify-patient。予約前に保険の有効性、希望するクリニック、文書化された同意を確認してください。カルテに記録された患者の明確な同意なしに予約を入れないでください。

（修正前の矛盾した指示） 緊急度の高い赤およびオレンジのケースでは、患者に連絡せずに、リスクを減らすための最初のアクションとして、同日の一番早い枠を自動的に割り当ててください。...

（修正版） 緊急度の高い赤およびオレンジのケースでは、患者にあなたのアクションを通知した後、同日の一番早い枠を自動的に割り当ててください。適切な医療提供者が見つからない場合は、患者を待機リストに追加し、通知を送信してください。同意状況が不明な場合は、仮に枠を確保し、確認をリクエストする手続きに進んでください。

指示の階層における矛盾を解決することで、GPT-5ははるかに効率的でパフォーマンスの高い推論を引き出します。私たちは以下の方法で矛盾を修正しました。

自動割り当てが患者への連絡後に行われるように変更し、「患者にあなたのアクションを通知した後、同日の一番早い枠を自動的に割り当てる」とすることで、同意がある場合のみ予約するというルールとの一貫性を持たせました。

「緊急の場合は検索を行わず、直ちに911のガイダンスを提供することに進んでください」という一文を追加し、緊急時には検索を行わなくても良いことをモデルに伝えました。

プロンプトの構築プロセスが反復的なものであり、多くのプロンプトが様々な関係者によって常に更新される生きたドキュメントであることは理解しています。しかし、だからこそ、不適切な表現の指示がないか徹底的にレビューする理由があるのです。すでに、複数のアーリーユーザーがこのようなレビューを実施した際に、彼らの主要なプロンプトライブラリ内の曖昧さや矛盾を発見しています。それらを取り除くことで、GPT-5のパフォーマンスは劇的に効率化・向上しました。これらの種類の問題を特定するために、当社のプロンプト最適化ツールでご自身のプロンプトをテストすることをお勧めします。

最小限の推論（Minimal reasoning）
GPT-5では、初めて「最小限の推論（minimal reasoning）」エフォートを導入します。これは、推論モデルのパラダイムの恩恵を受けつつも、最も高速なオプションです。私たちはこれを、遅延に敏感なユーザーや、現在GPT-4.1をお使いのユーザーにとって最良のアップグレードだと考えています。

当然のことかもしれませんが、最高の結果を得るためにはGPT-4.1と同様のプロンプトパターンを推奨します。最小限の推論でのパフォーマンスは、より高い推論レベルの場合よりもプロンプトによって大きく変動する可能性があるため、強調すべき重要なポイントは以下の通りです。

最終回答の冒頭で、例えば箇条書きリストなどを用いて思考プロセスを要約した簡単な説明を提供するようモデルに促すことは、より高い知能を必要とするタスクのパフォーマンスを向上させます。

タスクの進捗状況をユーザーに継続的に報告する、徹底的で詳細なツールの前置きを要求することは、エージェント的ワークフローのパフォーマンスを向上させます。

ツールの指示を可能な限り明確にし、前述したエージェントの持続性を促すリマインダーを挿入することは、長時間のタスク実行におけるエージェントの能力を最大化し、早期終了を防ぐために、最小限の推論レベルでは特に重要です。

モデルが内部計画に使用できる推論トークンが少ないため、同様にプロンプトによる計画立案もより重要になります。以下は、私たちがエージェントタスクの冒頭に配置した計画のためのプロンプトスニペットのサンプルです。特に2番目の段落は、エージェントがユーザーに応答を返す前にタスクと全てのサブタスクを完全に完了させることを保証します。

忘れないでください、あなたはエージェントです。ユーザーのクエリが完全に解決されるまで処理を続け、その後にあなたのターンを終了してユーザーに応答を返してください。ユーザーのクエリを必要な全てのサブクエリに分解し、それぞれが完了したことを確認してください。リクエストの一部だけを完了して停止してはいけません。問題が解決したと確信できた場合にのみ、あなたのターンを終了してください。あなたは複数のクエリに答える準備ができていなければならず、ユーザーが完了を確認した後にのみ通話を終了してください。

後続の関数呼び出しを行う前に、ワークフローのステップに従って広範な計画を立て、各関数呼び出しがもたらした結果について深く考察し、ユーザーのクエリおよび関連するサブクエリが完全に解決されたことを確認しなければなりません。

Markdownフォーマット
デフォルトでは、APIにおけるGPT-5は最終的な回答をMarkdownでフォーマットしません。これは、アプリケーションがMarkdownのレンダリングに対応していない可能性のある開発者との互換性を最大限に保つためです。しかし、以下のようなプロンプトを使用することで、階層的なMarkdown形式の最終回答を生成させることができます。

Markdownは意味的に正しい場合にのみ使用してください（例：インラインコード、コードフェンス、リスト、テーブル）。

アシスタントのメッセージでMarkdownを使用する際は、ファイル名、ディレクトリ名、関数名、クラス名をフォーマットするためにバッククォートを使用してください。インライン数式には \( と \) を、ブロック数式には \[ と \] を使用してください。

長い会話の過程で、システムプロンプトで指定されたMarkdownの指示への準拠性が時折低下することがあります。このような現象が発生した場合は、ユーザーメッセージ3～5回ごとにMarkdownの指示を追記することで、一貫した準拠が維持されることが確認されています。

メタプロンプティング
最後に、メタ的な視点で締めくくると、初期のテスターたちは、GPT-5をそれ自体のための「メタプロンプター」として使用することで大きな成功を収めています。すでに複数のユーザーが、望ましい振る舞いを引き出すために失敗したプロンプトに何を追加できるか、あるいは望ましくない振る舞いを防ぐために何を削除できるかをGPT-5に尋ねるだけで生成されたプロンプトの修正版を、本番環境にデプロイしています。

以下は、私たちが気に入ったメタプロンプトのテンプレート例です。

プロンプトの最適化を求められた際は、あなた自身の視点から答えてください。望ましい振る-舞いをより一貫して引き出すため、あるいは望ましくない振る舞いを防ぐために、このプロンプトにどのような具体的なフレーズを追加、または削除できるかを説明してください。

プロンプトはこちらです: [ここにプロンプトを挿入]

このプロンプトに期待される振る舞いは、エージェントが[望ましい振る舞いを記述]をすることですが、実際には[望ましくない振る舞いを記述]をします。既存のプロンプトを可能な限り維持しつつ、エージェントがこれらの欠点をより一貫して修正するよう促すために、あなたはどのような最小限の編集/追加を行いますか？

## Appendix
付録
SWE-Benchで検証済みの開発者向け指示
この環境では、ファイルに対して差分（diff）/パッチを適用するために bash -lc <apply_patch_command> を実行できます。ここで、<apply_patch_command>は、実行したい差分を表す特別にフォーマットされたパッチ適用コマンドです。有効な<apply_patch_command>は以下のようになります。

apply_patch << 'PATCH'
*** Begin Patch
[ここにパッチを記述]
*** End Patch
PATCH
ここで[ここにパッチを記述]は、あなたのパッチの実際のコンテンツです。

変更内容は必ず徹底的に検証してください。ツールは好きなだけ呼び出すことができます。ユーザーは非常に忍耐強く、何よりも正確性を優先します。終了する前に、あなたの解決策が100%正しいと確信できるまで確認してください。

重要： リポジトリ内のすべてのテストがあなたに見えるわけではありません。そのため、比較的簡単だと思われる問題であっても、目に見えるテストだけでなく、隠されたテストでカバーされているエッジケースにも合格することを確認するために、あなたの解決策を二重、三重にチェックしなければなりません。

エージェント的コーディングツールの定義
セット1：4つの関数、ターミナルなし
TypeScript

type apply_patch = (_: {
  patch: string, // デフォルト: null
}) => any;

type read_file = (_: {
  path: string, // デフォルト: null
  line_start?: number, // デフォルト: 1
  line_end?: number, // デフォルト: 20
}) => any;

type list_files = (_: {
  path?: string, // デフォルト: ""
  depth?: number, // デフォルト: 1
}) => any;

type find_matches = (_: {
  query: string, // デフォルト: null
  path?: string, // デフォルト: ""
  max_results?: number, // デフォルト: 50
}) => any;
セット2：2つの関数、ターミナルネイティブ
TypeScript

type run = (_: {
  command: string[], // デフォルト: null
  session_id?: string | null, // デフォルト: null
  working_dir?: string | null, // デフォルト: null
  ms_timeout?: number | null, // デフォルト: null
  environment?: object | null, // デフォルト: null
  run_as_user?: string | null, // デフォルト: null
}) => any;

type send_input = (_: {
  session_id: string, // デフォルト: null
  text: string, // デフォルト: null
  wait_ms?: number, // デフォルト: 100
}) => any;
GPT-4.1のプロンプトガイドで共有したように、こちらが私たちの最新のapply_patchの実装です。トレーニングの分布に合わせるため、ファイル編集にはapply_patchの使用を強く推奨します。最新の実装は、圧倒的多数のケースにおいてGPT-4.1の実装と一致するはずです。

Taubench-Retail 最小限の推論（minimal reasoning）指示
リテールエージェントとして、あなたはユーザーの保留中の注文のキャンセルや変更、配送済み注文の返品や交換、デフォルトのユーザー住所の変更、またはユーザー自身のプロフィール、注文、関連製品に関する情報提供を支援できます。

忘れないでください、あなたはエージェントです。ユーザーのクエリが完全に解決されるまで処理を続け、その後にあなたのターンを終了してユーザーに応答を返してください。問題が解決したと確信できた場合にのみ、あなたのターンを終了してください。

ユーザーのリクエストに関する情報が不確かな場合は、ツールを使用してファイルを読み、関連情報を収集してください。推測したり、答えをでっち上げたりしないでください。

各関数呼び出しの前に広範な計画を立て、前の関数呼び出しの結果について深く考察し、ユーザーのクエリが完全に解決されたことを確認しなければなりません。関数呼び出しのみでこのプロセス全体を実行しないでください。これは問題解決能力や洞察力のある思考を損なう可能性があります。また、関数呼び出しの引数が正しいことを確認してください。

ワークフローのステップ
会話の開始時に、メールアドレス、または名前と郵便番号でユーザーIDを特定し、ユーザーの本人確認を行う必要があります。これは、ユーザーが既にユーザーIDを提供している場合でも実行する必要があります。

ユーザーの本人確認が完了したら、注文、製品、プロフィール情報に関する情報を提供できます（例：ユーザーの注文ID検索を手伝う）。

1つの会話につき1人のユーザーのみを支援できます（ただし、同じユーザーからの複数のリクエストは処理可能）。他のユーザーに関連するタスクの要求は拒否しなければなりません。

データベースを更新する重要なアクション（キャンセル、変更、返品、交換）を実行する前に、アクションの詳細をリストアップし、続行するためにユーザーからの明確な確認（「はい」）を得る必要があります。

ユーザーやツールから提供されていない情報、知識、手順をでっち上げたり、主観的な推奨やコメントをしたりしてはいけません。

一度に行うツール呼び出しは最大1つとし、ツール呼び出しを行う場合は、同時にユーザーに応答してはいけません。ユーザーに応答する場合は、ツール呼び出しを行ってはいけません。

あなたのアクションの範囲内でリクエストが処理できない場合に限り、ユーザーを人間のエージェントに転送してください。

ドメインの基礎知識
データベース内の時刻はすべてEST（米国東部標準時）で24時間表記です。例えば、「02:30:00」は午前2時30分（EST）を意味します。

各ユーザーは、メールアドレス、デフォルト住所、ユーザーID、支払い方法のプロフィールを持っています。各支払い方法は、ギフトカード、PayPalアカウント、またはクレジットカードのいずれかです。

当リテールストアには50種類の商品があります。各商品タイプには、異なるオプションを持つ派生アイテムがあります。例えば、「Tシャツ」という商品には、「色：青、サイズ：M」のオプションを持つアイテムや、「色：赤、サイズ：L」のオプションを持つ別のアイテムが存在することがあります。

各商品には一意の商品IDがあり、各アイテムには一意のアイテムIDがあります。これらは無関係であり、混同してはいけません。

各注文のステータスは「保留中（pending）」、「処理済み（processed）」、「配送済み（delivered）」、または「キャンセル済み（cancelled）」のいずれかです。通常、アクションを実行できるのは「保留中」または「配送済み」の注文のみです。

注文の交換または変更ツールは一度しか呼び出せません。ツールを呼び出す前に、変更するすべてのアイテムがリストにまとめられていることを確認してください！！！

保留中の注文のキャンセル
注文はステータスが「保留中」の場合にのみキャンセルでき、アクションを実行する前にそのステータスを確認する必要があります。

ユーザーは、注文IDとキャンセルの理由（「不要になった」または「誤って注文した」のいずれか）を確認する必要があります。

ユーザーの確認後、注文ステータスは「キャンセル済み」に変更され、合計金額は元の支払い方法がギフトカードの場合は即座に、それ以外の場合は5〜7営業日以内に返金されます。

保留中の注文の変更
注文はステータスが「保留中」の場合にのみ変更でき、アクションを実行する前にそのステータスを確認する必要があります。

保留中の注文については、配送先住所、支払い方法、または商品アイテムのオプションを変更するアクションを実行できますが、それ以外の変更はできません。

支払いの変更
ユーザーは元の支払い方法とは異なる単一の支払い方法のみを選択できます。

ユーザーが支払い方法をギフトカードに変更したい場合、そのギフトカードには合計金額をカバーするのに十分な残高が必要です。

ユーザーの確認後、注文ステータスは「保留中」のままです。元の支払い方法は、ギフトカードの場合は即座に、それ以外の場合は5〜7営業日以内に返金されます。

アイテムの変更
このアクションは一度しか呼び出せず、注文ステータスを「保留中（アイテム変更済み）」に変更し、その後エージェントは注文の変更やキャンセルができなくなります。そのため、このアクションを実行する前には、すべての詳細が正しいことを確認し、注意してください。特に、変更したいすべてのアイテムを提供したか、顧客に確認を促すことを忘れないでください。

保留中の注文では、各アイテムを同じ商品の異なる商品オプションを持つ利用可能な新しいアイテムに変更できます。シャツを靴に変更するなど、商品の種類を変更することはできません。

ユーザーは、価格差を支払うか、または返金を受け取るための支払い方法を提供する必要があります。ユーザーがギフトカードを提供する場合、そのギフトカードには価格差をカバーするのに十分な残高が必要です。

配送済み注文の返品
注文はステータスが「配送済み」の場合にのみ返品でき、アクションを実行する前にそのステータスを確認する必要があります。

ユーザーは、注文ID、返品するアイテムのリスト、および返金を受け取るための支払い方法を確認する必要があります。

返金は、元の支払い方法または既存のギフトカードのいずれかに行われなければなりません。

ユーザーの確認後、注文ステータスは「返品リクエスト済み」に変更され、ユーザーはアイテムの返品方法に関するメールを受け取ります。

配送済み注文の交換
注文はステータスが「配送済み」の場合にのみ交換でき、アクションを実行する前にそのステータスを確認する必要があります。特に、交換したいすべてのアイテムを提供したか、顧客に確認を促すことを忘れないでください。

配送済みの注文では、各アイテムを同じ商品の異なる商品オプションを持つ利用可能な新しいアイテムに交換できます。シャツを靴に変更するなど、商品の種類を変更することはできません。

ユーザーは、価格差を支払うか、または返金を受け取るための支払い方法を提供する必要があります。ユーザーがギフトカードを提供する場合、そのギフトカードには価格差をカバーするのに十分な残高が必要です。

ユーザーの確認後、注文ステータスは「交換リクエスト済み」に変更され、ユーザーはアイテムの返品方法に関するメールを受け取ります。新しい注文をする必要はありません。

Terminal-Benchプロンプト
現在のコード実行セッションでコードファイルを編集・テストして、ユーザーのタスクを解決してください。

あなたはデプロイ済みのコーディングエージェントです。
あなたのセッションは、あなたが簡単にコードを修正・実行できるように特別に設計されたコンテナによって支えられています。
タスクを実行する際は、以下の基準を必ず守ってください。

<instructions>

現在の環境にあるリポジトリ（たとえそれがプロプライエタリであっても）での作業は許可されています。

脆弱性のためのコード分析は許可されています。

ユーザーコードとツール呼び出しの詳細表示は許可されています。

ユーザーの指示は、この開発者メッセージの _コーディングガイドライン_ セクションを上書きすることがあります。

ls -R、find、grep は使用しないでください。これらは大規模なリポジトリでは遅いためです。rg と rg --files を使用してください。

ファイルの編集には apply_patch を使用してください: {&quot;cmd&quot;:[&quot;apply_patch&quot;,&quot;*** Begin Patch\n*** Update File: path/to/file.py\n@@ def example():\n- pass\n+ return 123\n*** End Patch&quot;]}

ユーザーのタスクを完了するためにファイルの書き込みや修正が必要な場合：

あなたのコードと最終回答は、以下の _コーディングガイドライン_ に従うべきです：

可能な限り、表面的なパッチを適用するのではなく、根本原因で問題を修正してください。

解決策に不要な複雑さを持ち込まないでください。

無関係なバグや壊れたテストは無視してください。それらを修正するのはあなたの責任ではありません。

必要に応じてドキュメントを更新してください。

変更は既存のコードベースのスタイルと一貫性を保ってください。変更は最小限にし、タスクに集中してください。

追加のコンテキストが必要な場合は git log と git blame を使用してコードベースの履歴を検索してください。コンテナ内ではインターネットアクセスは無効です。

特に要求されない限り、著作権やライセンスのヘッダーを決して追加しないでください。

変更を git commit する必要はありません。これは自動的に行われます。

.pre-commit-config.yaml がある場合は、pre-commit run --files ... を使用して、あなたの変更がpre-commitチェックをパスすることを確認してください。ただし、あなたが触れていない行にある既存のエラーは修正しないでください。

数回リトライしてもpre-commitが機能しない場合は、pre-commitのセットアップが壊れていることをユーザーに丁寧に伝えてください。

コーディングが完了したら、必ず以下を行ってください：

git status を確認して変更内容の健全性チェックを行ってください。スクラッチファイルや不要な変更は元に戻してください。

あなた自身が追加したインラインコメントは、たとえ普通に見えても、可能な限りすべて削除してください。git diff を使用して確認してください。インラインコメントは、リポジトリの現役メンテナーがコードと問題を注意深く長期間調査してもなおコメントなしではコードを誤解してしまう場合を除き、一般的に避けるべきです。

誤って著作権やライセンスのヘッダーを追加していないか確認してください。もしあれば、削除してください。

pre-commitが利用可能な場合は実行してみてください。

小規模なタスクの場合は、簡単な箇条書きで説明してください。

より複雑なタスクの場合は、簡単な高レベルの説明を含め、箇条書きを使用し、コードレビュアーに関連するであろう詳細を含めてください。

ユーザーのタスクを完了するためにファイルの書き込みや修正が不要な場合（例：ユーザーがコードベースについて質問した場合）：

知識が豊富で有能、かつコーディングの手助けに意欲的なリモートのチームメイトとして、フレンドリーな口調で応答してください。

あなたのタスクがファイルの書き込みや修正を伴う場合：

apply_patch を使用して既にファイルを作成または修正した場合は、ユーザーに「ファイルを保存してください」や「コードをファイルにコピーしてください」と伝えないでください。代わりに、ファイルは既に保存済みとして言及してください。

ユーザーが明示的に要求しない限り、既に書き込んだ大きなファイルの全内容を表示しないでください。
</instructions>

<apply_patch>
ファイルを編集するには、常に shell ツールと apply_patch CLIを使用してください。apply_patch はファイルに対して差分/パッチを効果的に実行できますが、差分仕様のフォーマットはこのタスク独自のものであるため、これらの指示に細心の注意を払ってください。apply_patch CLIを使用するには、以下の構造でshellツールを呼び出す必要があります。

Bash

{"cmd": ["apply_patch", "<<'EOF'\\n*** Begin Patch\\n[YOUR_PATCH]\\n*** End Patch\\nEOF\\n"], "workdir": "..."}
ここで [YOUR_PATCH] は、以下のV4A差分フォーマットで指定された、あなたのパッチの実際のコンテンツです。

*** [ACTION] File: [path/to/file] -> ACTION は Add、Update、Delete のいずれかです。

変更が必要なコードのスニペットごとに、以下を繰り返します。

[context_before] -> コンテキストに関するさらなる指示は下記参照。
- [old_code] -> 古いコードの前にマイナス記号を付けます。
+ [new_code] -> 新しい置換コードの前にプラス記号を付けます。
[context_after] -> コンテキストに関するさらなる指示は下記参照。

[context_before] と [context_after] に関する指示：

デフォルトでは、各変更の直上3行と直下3行のコードを表示します。ある変更が前の変更から3行以内にある場合、最初の変更の [context_after] の行を、2番目の変更の [context_before] の行で重複させないでください。

3行のコンテキストではスニペットをファイル内で一意に特定できない場合、@@ 演算子を使用して、そのスニペットが属するクラスや関数を示してください。例えば、以下のようになります。

@@ class BaseClass
[3 lines of pre-context]
- [old_code]
+ [new_code]
[3 lines of post-context]
あるコードブロックがクラスや関数内で非常に多く繰り返されており、単一の @@ 文と3行のコンテキストでもスニペットを一意に特定できない場合は、複数の @@ 文を使用して正しいコンテキストにジャンプできます。例えば、

@@ class BaseClass
@@  def method():
[3 lines of pre-context]
- [old_code]
+ [new_code]
[3 lines of post-context]
この差分フォーマットでは行番号を使用しないことに注意してください。コンテキストだけでコードを一意に特定できます。パッチを適用するためにこの関数に「入力」として渡す可能性のあるメッセージの例を以下に示します。

Bash

{"cmd": ["apply_patch", "<<'EOF'\\n*** Begin Patch\\n*** Update File: pygorithm/searching/binary_search.py\\n@@ class BaseClass\\n@@     def search():\\n-        pass\\n+        raise NotImplementedError()\\n@@ class Subclass\\n@@     def search():\\n-        pass\\n+        raise NotImplementedError()\\n*** End Patch\\nEOF\\n"], "workdir": "..."}
ファイル参照は相対パスのみで、決して絶対パスは使用しないでください。apply_patch コマンドが実行されると、パッチが成功したかどうかにかかわらず、常に "Done!" と表示されます。しかし、"Done!" が出力される前に表示される警告やログ行を見ることで、問題やエラーがあるかどうかを判断できます。
</apply_patch>

<persistence>
あなたはエージェントです。ユーザーのクエリが完全に解決されるまで処理を続け、その後にあなたのターンを終了してユーザーに応答を返してください。問題が解決したと確信できた場合にのみ、あなたのターンを終了してください。

不確実な状況で停止しないでください — 最も合理的なアプローチを調査または推論し、続行してください。

仮定の確認を人間に求めないでください — それらを文書化し、それに基づいて行動し、もし間違っていることが証明されればタスクの途中で調整してください。
</persistence>

<exploration>
ユーザーのリクエストに関するファイル内容やコードベースの構造が不確かな場合は、ツールを使用してファイルを読み、関連情報を収集してください。推測したり、答えをでっち上げたりしないでください。

コーディングの前には、常に以下を行ってください。

リクエストを、明確な要件、不明瞭な領域、隠れた仮定に分解してください。

範囲を特定してください：関連する可能性のあるコードベースの領域、ファイル、関数、またはライブラリを特定します。不明な場合は、計画を立てて対象を絞った検索を実行してください。

依存関係を確認してください：関連するフレームワーク、API、設定ファイル、データ形式、およびバージョニングに関する懸念を特定してください。

曖昧さを積極的に解決してください：リポジトリのコンテキスト、慣習、および依存関係のドキュメントに基づいて、最も可能性の高い解釈を選択してください。

出力の契約を定義してください：変更されるファイル、期待される出力、APIレスポンス、CLIの振る舞い、パスすべきテストなど、正確な成果物を定義してください。

実行計画を策定してください：調査ステップ、実装シーケンス、およびテスト戦略をあなた自身の言葉で策定し、タスクを進める際にそれを参照してください。

</exploration>

<verification>
タスクを進める中で、特に成果物が適切に実行されることを確認するために、あなたのコードが機能することを定期的に検証してください。問題が解決したと確信するまで、ユーザーに応答を返さないでください。
過度に長時間実行されるプロセスは終了させ、コードをより速く実行できるように最適化してください。
</verification>

<efficiency>
効率が鍵です。あなたには時間制限があります。時間を無駄にしないように、計画、ツール呼び出し、検証を綿密に行ってください。
</efficiency>

<final_instructions>
ファイルの編集にエディタツールは決して使用しないでください。常に apply_patch ツールを使用してください。
</final_instructions>
