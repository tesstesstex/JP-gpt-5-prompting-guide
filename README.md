# JP-gpt-5-prompting-guide
[元記事](https://cookbook.openai.com/examples/gpt-5/gpt-5_prompting_guide)

# 本文翻訳
# JP-gpt-5-prompting-guide
[元記事](https://cookbook.openai.com/examples/gpt-5/gpt-5_prompting_guide)

# 本文翻訳
当社の最新フラッグシップモデルであるGPT-5は、エージェント的なタスク遂行能力、コーディング、基礎知能、そして制御性において、大きな飛躍を遂げています。

GPT-5は幅広い分野で「初期設定のまま」でも優れた性能を発揮すると確信していますが、このガイドでは、私たちがモデルのトレーニングや実世界での応用から学んだ、最高のパフォーマンスを引き出すための具体的なプロンプト戦略とAPIのベストプラクティスを紹介します。

これらのベストプラクティスを適用し、可能な限り当社の標準ツールを採用することで、私たちは大きな成果を上げてきました。このガイドが、皆さんのアプリケーション開発の一助となれば幸いです。

## エージェント的ワークフローの予測可能性
私たちは開発者を念頭に置いてGPT-5をトレーニングしました。エージェント的なアプリケーションに最適な基盤モデルとなるよう、ツール呼び出し、推論、そして計画能力を全面的に刷新しました。

GPT-5をエージェント的フローやツール呼び出しフローに採用される場合は、Responses APIへのアップグレードを推奨します。このAPIでは、ツール呼び出しのシーケンス全体で推論コンテキストを再利用でき、コストを削減しながらパフォーマンスを向上させることができます。

### エージェントの積極性を制御する
エージェントを制御する仕組みは、その制御の度合いが多岐にわたります。意思決定の大部分を基盤モデルに委任するシステムもあれば、厳格なプロンプトを通じてモデルの行動を制約するシステムもあります。

#### 積極性を抑えるためのプロンプト
GPT-5は、正しい答えを生成できるようにするため、デフォルトではエージェント環境でコンテキストを収集する際に徹底的かつ包括的に動作します。しかし、場合によっては、より迅速な応答を得るために、この積極性を抑えたいこともあるでしょう。

- `reasoning_effort`を低く設定します。これにより探索の深さは浅くなりますが、効率と遅延は改善されます。多くのワークフローは、`reasoning_effort`が中程度または低い設定で最適に機能します。
- モデルに問題空間をどのように探索してほしいかについて、プロンプトで明確な基準を定義します。これにより、モデルが過剰なアイデアを探索・検証することなく、より直接的に目標に向かうようになります。

```xml
<context_gathering>
目標: 迅速に十分なコンテキストを得る。発見プロセスを並列化し、行動可能になり次第停止する。
手法:
- 広く開始し、その後、焦点を絞ったサブクエリに展開する。
- 並行して多様なクエリを実行し、クエリごとに上位のヒットを読む。パスの重複を排除してキャッシュし、クエリを繰り返さない。
- コンテキストの過剰な検索を避ける。必要であれば、対象を絞った検索を1つの並列バッチで実行する。
早期停止基準:
- 変更すべき正確なコンテンツを特定できる。
- 上位のヒットが1つの領域/パスに収束する（約70%）。
一度だけエスカレーション:
- シグナルが競合したり、範囲が曖昧な場合は、洗練された並列バッチを1回実行してから続行する。
深さ:
- 変更するシンボル、またはその契約に依存するシンボルのみを追跡する。不要な限り推移的な展開は避ける。
ループ:
- バッチ検索 → 最小限の計画 → タスク完了。
- 検証が失敗した場合、または新たな不明点が現れた場合にのみ再検索する。検索よりも行動を優先する。
</context_gathering>
```

最大限に指示的にしたい場合は、以下のようにツール呼び出しの固定予算を設定することもできます。この予算は、希望する検索の深さに応じて柔軟に調整できます。

```xml
<context_gathering>
- 検索の深さ: 非常に浅い
- たとえ完全には正しくない可能性があっても、できるだけ早く正解を提供することを強く優先する。
- 通常、これはツール呼び出しが絶対最大2回であることを意味する。
- 調査にもっと時間が必要だと判断した場合は、最新の調査結果と未解決の質問をユーザーに報告する。ユーザーが承認すれば続行できる。
</context_gathering>
```

中核となるコンテキスト収集の振る舞いを制限する際には、モデルに明確な「緊急避難口」（エスケープハッチ）を設けることが有効です。これにより、タスクが複雑すぎることが判明した場合に、モデルがユーザーに助けを求めることができます。

#### 積極性を高めるためのプロンプト
一方で、モデルの自律性を促進し、ツール呼び出しの持続性を高め、確認のための質問やユーザーへの処理の差し戻しを減らしたい場合は、`reasoning_effort`を高く設定し、以下のようなプロンプトをシステムプロンプトに含めることを推奨します。

```xml
<persistence>
- あなたはエージェントです。ユーザーのクエリが完全に解決されるまで処理を続け、その後にあなたのターンを終了してユーザーに応答を返してください。
- 問題が解決したと確信できた場合にのみ、あなたのターンを終了してください。
- 不確実な状況に遭遇しても、決して停止したりユーザーに処理を戻したりしないでください。最も合理的なアプローチを調査または推論し、処理を続けてください。
- 後でいつでも調整できるため、人間に仮定の確認や明確化を求めないでください。最も合理的な仮定を決定し、それに基づいて処理を進め、行動が間違っていたことが判明した場合にはタスクの途中で調整してください。
</persistence>
```
一般的に、エージェントタスクの停止条件を明確に述べ、安全なアクションと危険なアクションの概要を示し、モデルがユーザーに処理を差し戻すタイミングと方法に関するガイドラインを提供することが、予測可能性を高める上で非常に効果的です。

### ツールの前置き (Tool preambles)
ユーザーが監視するエージェントの一連の動作において、モデルがツール呼び出しで何を行い、なぜそうしているのかを断続的に報告することで、ユーザーはエージェントの思考プロセスをより深く理解できるようになります。

プロンプトを通じて、ツールの前置きの頻度、スタイル、内容を、個々のツール呼び出しに関する詳細な説明から簡潔な事前計画まで、自在に制御できます。

```xml
<tool_preambles>
- ツールを呼び出す前に、必ずユーザーの目標をフレンドリー、明確、かつ簡潔な言葉で言い換えることから始めてください。
- 次に、実行する各論理ステップを詳述した構造化された計画の概要をただちに示してください。
- ファイル編集を実行する際は、各ステップを簡潔かつ順を追って説明し、進捗を明確に示してください。
- 最後に、完了した作業を事前の計画とは区別して明確に要約してください。
</tool_preambles>
```
以下は、このようなプロンプトに応じて生成されうるツールの前置きの例です。エージェントの作業が複雑化するにつれて、このような前置きはユーザーにとって非常に価値のあるものになります。

```json
"output": [
    {
      "id": "rs_6888f6d0606c819aa8205ecee386963f0e683233d39188e7",
      "type": "reasoning",
      "summary": [
        {
          "type": "summary_text",
          "text": "**天気の応答を決定**\n\nサンフランシスコの天気に関するユーザーの質問に答える必要があります。...."
        }
      ]
    },
    {
      "id": "msg_6888f6d83acc819a978b51e772f0a5f40e683233d39188e7",
      "type": "message",
      "status": "completed",
      "content": [
        {
          "type": "output_text",
          "text": "ライブの天気情報サービスでサンフランシスコの現在の気象状況を確認し、お客様の好みに合わせて気温を華氏と摂氏の両方でお伝えします。"
        }
      ],
      "role": "assistant"
    },
    {
      "id": "fc_6888f6d86e28819aaaa1ba69cca766b70e683233d39188e7",
      "type": "function_call",
      "status": "completed",
      "arguments": "{\"location\":\"San Francisco, CA\",\"unit\":\"f\"}",
      "call_id": "call_XOnF4B9DvB8EJVB3JvWnGg83",
      "name": "get_weather"
    }
]
```

### Reasoning effort（推論の労力）
私たちは、モデルがどれだけ深く思考し、どれだけ積極的にツールを呼び出すかを制御するための`reasoning_effort`パラメータを提供しています。デフォルトでは、reasoning_effortは`auto`に設定されており、モデルがタスクの複雑さに応じて推論の深さを動的に調整します。

### Responses APIによる推論コンテキストの再利用
GPT-5を使用する際には、改善されたエージェント的フローの実現、コスト削減、そしてアプリケーションにおけるトークン使用の効率化のために、Responses APIにアップグレードすることを強くお勧めします。

Chat Completionsの代わりにResponses APIを使用した場合、評価において統計的に有意な改善が見られます。例えば、単にResponses APIに切り替え、後続のリクエストでreasoning_idを再利用するだけで、SWE-Benchのスコアが2%向上しました。

## コーディング性能の最大化：計画から実行まで
GPT-5は、コーディング能力において全ての最先端モデルをリードしています。大規模なコードベースでのバグ修正、大規模な差分（diff）の取り扱い、そしてゼロからのアプリケーション生成において、新たな基準を打ち立てています。

### フロントエンドアプリ開発
GPT-5は、その厳密な実装能力に加え、優れた基本的な美的センスも持ち合わせるようにトレーニングされています。私たちは、GPT-5があらゆる種類のWebアプリケーションのプロトタイピングと構築において、ほぼ即座に高品質な結果を出せることに大きな期待を寄せています。以下は、モデルが最も得意とするフロントエンドスタックです。

- **フレームワーク:** Next.js (TypeScript), React, HTML
- **スタイリング / UI:** Tailwind CSS, shadcn/ui, Radix Themes
- **アイコン:** Material Symbols, Heroicons, Lucide
- **アニメーション:** Motion
- **フォント:** San Serif, Inter, Geist, Mona Sans, IBM Plex Sans, Manrope

#### ゼロからのアプリ生成
GPT-5は、アプリケーションを一度の指示（ワンショット）で構築することに優れています。このモデルの初期実験において、ユーザーは以下のような自己反省（self-reflection）のプロンプトを使用することで、特に優れた結果を得ています。

```xml
<self_reflection>
- まず、自信が持てるまで、評価基準（ルーブリック）について時間をかけて考えてください。
- 次に、世界クラスのワンショットWebアプリを構成するあらゆる側面について深く考えてください。その知識を使い、5〜7個のカテゴリを持つ評価基準を作成してください。
- 最後に、その評価基準を使って、与えられたプロンプトに対する最善の解決策を内部で考え、繰り返し検討してください。もしあなたの応答が評価基準のいずれかの側面で不十分な場合は、より良い解決策が見つかるまで、内部で繰り返し修正してください。
</self_reflection>
```

#### コードベースの設計基準に合わせる
既存のアプリで段階的な変更やリファクタリングを実装する際、モデルが生成したコードは既存のスタイルや設計基準に従い、可能な限り自然にコードベースに統合されるべきです。

```xml
<code_editing_rules>
<guiding_principles>
- 明確性と再利用性: すべてのコンポーネントとページは、モジュール化され再利用可能であるべきです。繰り返されるUIパターンをコンポーネントとして抽象化してください。
- 一貫性: ユーザーインターフェースは一貫したデザインシステムに従う必要があります。カラートークン、タイポグラフィ、スペーシング、コンポーネントのバリエーションは、既存のパターンに沿っているべきです。
- シンプルさ: 小さく、焦点を絞ったコンポーネントを優先し、スタイリングやロジックにおける不必要な複雑さを避けてください。
- デモ指向: ストリーミング、複数ターンの対話、ツール統合といった機能のデモができるよう、迅速なプロトタイピングが可能な構造にしてください。
- 視覚的な品質: OSSガイドラインで概説されている高い視覚的品質基準（スペーシング、パディング、ホバー状態など）に従ってください。
</guiding_principles>
<frontend_stack_defaults>
- フレームワーク: Next.js (TypeScript)
- スタイリング: TailwindCSS
- UIコンポーネント: shadcn/ui
- アイコン: Lucide
- 状態管理: Zustand
- ディレクトリ構造: 
  ```
  /src
   /app
     /api/<route>/route.ts         # APIエンドポイント
     /(pages)                      # ページルート
   /components/                    # UIビルディングブロック
   /hooks/                         # 再利用可能なReactフック
   /lib/                           # ユーティリティ (fetcher, ヘルパー)
   /stores/                        # Zustandストア
   /types/                         # 共有TypeScript型
   /styles/                        # Tailwind設定
  ```
</frontend_stack_defaults>
<ui_ux_best_practices>
- 視覚的階層: 一貫した階層のために、タイポグラフィを4〜5種類のフォントサイズとウェイトに制限してください。キャプションや注釈には `text-xs` や `text-sm` を使用してください。
- 色の使用: 1色のニュートラルなベースカラー（例: `zinc`）と、最大2色のアクセントカラーを使用してください。
- スペーシングとレイアウト: 視覚的なリズムを保つため、パディングとマージンには常に4の倍数を使用してください。長いコンテンツストリームを分割するために、十分なホワイトスペースを確保してください。
- 状態のハンドリング: データ取得中を示すには、スケルトンプレースホルダーまたは `animate-pulse` を使用してください。ホバー時のトランジションを追加して、インタラクティブな要素を強調してください。
- アクセシビリティ: 適切な場所でセマンティックHTMLとARIAロールを使用してください。アクセシビリティが組み込まれている、ビルド済みのRadix/shadcnコンポーネントを優先してください。
</ui_ux_best_practices>
</code_editing_rules>
```

### 本番環境での共同コーディング：CursorによるGPT-5のプロンプトチューニング
AIコードエディタであるCursorに、信頼できるアルファテスターとしてGPT-5をご利用いただけたことを誇りに思います。以下では、Cursorがモデルの能力を最大限に引き出すために、どのようにシステムプロンプトとパラメータを調整したかについて、いくつかの重要な学びを共有します。

#### システムプロンプトとパラメータチューニング
Cursorのシステムプロンプトは、信頼性の高いツール呼び出しに重点を置き、冗長性と自律的な振る舞いのバランスを取りつつ、ユーザーがカスタム指示を通じてモデルを容易に制御できるように設計されています。

当初、チームはモデルが冗長な出力をすることに気づきました。これには、技術的には関連性があるもののユーザーの自然な作業フローを妨げるステップバイステップの思考プロセスが含まれていました。これを解決するため、彼らは`verbosity`を`low`に設定し、システムプロンプトに以下の指示を追加しました。

> まず明確さを第一にコードを書いてください。分かりやすい名前、必要な箇所へのコメント、そして簡潔な制御フローを持つ、可読性が高く保守しやすいコードを目指してください。

このパラメータとプロンプトの二重活用により、効率的で簡潔なステータス更新や作業要約と、はるかに可読性の高いコード差分（diff）とを組み合わせることができました。

Cursorはまた、モデルが行動を起こす前に明確化や次のステップをユーザーに確認することがあり、これが長期間のタスクフローにおいて不要な手間となることに気づきました。これを防ぐため、彼らはシステムプロンプトに以下の指示を追加しました。

> あなたが行うコード編集は、提案された変更としてユーザーに表示されることを認識してください。これは、(a) ユーザーはいつでも拒否できるため、あなたは大胆に行動できること、(b) ユーザーは既にあなたにタスクを委任しているため、明確化を求める必要はないこと、を意味します。

Cursorは、以前のモデルで効果的だったプロンプトの一部が、GPT-5の能力を最大限に引き出すためにはチューニングが必要であることに気づきました。例えば、以前は次のようなプロンプトを使用して、モデルに徹底的なコンテキスト収集を促していました。

```xml
<maximize_context_understanding>
情報を収集する際は徹底的に行ってください。返信する前に全体像を完全に把握していることを確認してください。必要に応じて、追加のツール呼び出しを行ってください。
...
</maximize_context_understanding>
```
これは、コンテキストを徹底的に分析するよう促す必要があった旧モデルではうまく機能しましたが、元々コンテキスト収集において内省的かつ積極的であるGPT-5では、冗長なツール呼び出しや過剰な思考につながることがありました。

これを解決するため、彼らは`maximize_`という接頭辞を削除し、徹底性に関する言葉遣いを和らげることでプロンプトを洗練させました。この調整されたプロンプトは、GPT-5の生来の能力をより効果的に活用します。

```xml
<context_understanding>
...
ユーザーのクエリを部分的に満たす可能性のある編集を行ったが、自信がない場合は、ターンを終了する前に追加の情報を収集するか、より多くのコンテキストを検索してください。
自分で答えを見つけられる場合は、ユーザーに助けを求めないことを優先してください。
</context_understanding>
```
システムプロンプトが強力なデフォルトの基盤を提供する一方で、ユーザープロンプトは依然として制御性（steerability）のための非常に効果的な手段です。

## 知能と指示追従性の最適化
### 制御性（ステアリング）
これまでで最も制御性の高いモデルとして、GPT-5は冗長性（verbosity）、トーン、そしてツール呼び出しの振る舞いに関するプロンプトの指示を非常に忠実に守ります。

#### 冗長性（Verbosity）
これまでの推論モデルと同様に`reasoning_effort`を制御できることに加え、GPT-5では`verbosity`という新しいAPIパラメータを導入しました。これは、思考の長さと最終的な回答の簡潔さを独立して制御するためのものです。

当社のブログ記事では、このパラメータの背景にある考え方をより詳しく解説していますが、このガイドでは特に次の点を強調します。APIの`verbosity`パラメータは、システムプロンプト内の冗長性に関する指示よりも常に優先されます。

### 指示追従性
GPT-4.1と同様に、GPT-5は極めて高い精度でプロンプトの指示に従います。これにより、あらゆる種類のワークフローに柔軟に組み込むことが可能ですが、プロンプト内の矛盾した指示が推論の失敗につながる可能性も高まります。

以下に示すのは、GPT-5の推論の軌跡を損ないがちなプロンプトの敵対的な例です。一見すると内部的に一貫しているように見えますが、よく調べると、モデルが効果的にタスクを実行することを妨げる、微妙な矛盾がいくつか見つかります。

- 「カルテに記録された患者の明確な同意なしに予約を入れない」という指示が、その後の「リスクを減らすための最初のアクションとして、患者に連絡せずに、同日の一番早い枠を自動的に割り当てる」という指示と矛盾しています。
- プロンプトには「他のいかなるアクションを起こす前にも、必ず患者プロファイルを検索して既存の患者であることを確認する」とありますが、その後の指示では「緊急の場合は検索を行わず、直ちに911のガイダンスを提供することに進んでください」とあり、矛盾しています。

**元のプロンプト**
> あなたはCareFlow Assistantです。ヘルスケアスタートアップの仮想アシスタントで、優先度と症状に基づいて患者の予約をスケジュールします。あなたは、患者、医療提供者、予約を管理する社内APIと対話します。
> 
> （修正版） 中核となるエンティティは、患者、医療提供者、予約、優先度レベル（赤、オレンジ、黄、緑）です。症状を優先度にマッピングします：重度の胸痛や呼吸困難は赤、高熱や持続する嘔吐はオレンジ、軽い切り傷や一般的な風邪は黄、定期的な健康診断や処方箋の補充は緑です。
> 
> 次の機能を使用してください：`schedule-appointment`, `modify-appointment`, `waitlist-add`, `find-provider`, `lookup-patient`, `notify-patient`。予約前に保険の有効性、希望するクリニックの場所、および好みの医療提供者を確認してください。
> 
> （修正前の矛盾した指示） 緊急度の高い赤およびオレンジのケースでは、患者に連絡せずに、リスクを減らすための最初のアクションとして、同日の一番早い枠を自動的に割り当ててください。
> 
> （修正版） 緊急度の高い赤およびオレンジのケースでは、患者にあなたのアクションを通知した後、同日の一番早い枠を自動的に割り当ててください。

指示の階層における矛盾を解決することで、GPT-5ははるかに効率的でパフォーマンスの高い推論を引き出します。私たちは以下の方法で矛盾を修正しました。

- 自動割り当てが患者への連絡後に行われるように変更し、「患者にあなたのアクションを通知した後、同日の一番早い枠を自動的に割り当てる」としました。
- 「緊急の場合は検索を行わず、直ちに911のガイダンスを提供することに進んでください」という一文を追加し、緊急時には検索を行わなくても良いという明確な例外を設けました。

プロンプトの構築プロセスが反復的なものであり、多くのプロンプトが様々な関係者によって常に更新される生きたドキュメントであることは理解しています。それでも、可能な限り、プロンプトの指示が内部的に一貫していることを確認するために、定期的に監査を行うことをお勧めします。

## 最小限の推論（Minimal reasoning）
GPT-5では、初めて「最小限の推論（minimal reasoning）」エフォートを導入します。これは、推論モデルのパラダイムの恩恵を受けつつも、最も高速なオープンソースモデルに匹敵する速度とコストを実現するためのものです。

当然のことかもしれませんが、最高の結果を得るためにはGPT-4.1と同様のプロンプトパターンを推奨します。最小限の推論でのパフォーマンスは、より詳細で具体的な指示を与えることで大幅に向上します。

- 最終回答の冒頭で、例えば箇条書きリストなどを用いて思考プロセスを要約した簡単な説明を提供するようモデルに促すことは、より高い知能を必要とするタスクにおいて、パフォーマンスを向上させることが示されています。
- タスクの進捗状況をユーザーに継続的に報告する、徹底的で詳細なツールの前置きを要求することは、エージェント的ワークフローのパフォーマンスを向上させます。
- ツールの指示を可能な限り明確にし、前述したエージェントの持続性を促すリマインダーを挿入することは、長時間のタスク実行におけるエージェントの回復力を高めます。

モデルが内部計画に使用できる推論トークンが少ないため、同様にプロンプトによる計画立案もより重要になります。以下は、私たちがエージェント的ワークフローのプロンプトに含めている計画に関する指示の例です。

> 忘れないでください、あなたはエージェントです。ユーザーのクエリが完全に解決されるまで処理を続け、その後にあなたのターンを終了してユーザーに応答を返してください。
>
> 後続の関数呼び出しを行う前に、ワークフローのステップに従って広範な計画を立て、各関数呼び出しがもたらした結果について深く考察し、ユーザーのクエリが完全に解決されたことを確認しなければなりません。

## Markdownフォーマット
デフォルトでは、APIにおけるGPT-5は最終的な回答をMarkdownでフォーマットしません。これは、アプリケーションがMarkdownのレンダリングに対応していない場合に、意図しない書式設定が表示されるのを防ぐためです。モデルにMarkdownを使用させたい場合は、システムプロンプトに以下の指示を含めてください。

- Markdownは意味的に正しい場合にのみ使用してください（例：インラインコード、コードフェンス、リスト、テーブル）。
- アシスタントのメッセージでMarkdownを使用する際は、ファイル名、ディレクトリ名、関数名、クラス名をフォーマットするためにバッククォートを使用してください（例：`README.md`）。

長い会話の過程で、システムプロンプトで指定されたMarkdownの指示への準拠性が時折低下することがあります。このような現象が発生した場合は、ユーザーのターンで簡単なリマインダーを送信することで、モデルの振る舞いを修正できます。

## メタプロンプティング
最後に、メタ的な視点で締めくくると、初期のテスターたちは、GPT-5をそれ自体のための「メタプロンプター」として使用することで大きな成功を収めています。

以下は、私たちが気に入ったメタプロンプトのテンプレート例です。

> プロンプトの最適化を求められた際は、あなた自身の視点から答えてください。望ましい振る舞いをより一貫して引き出すため、あるいは望ましくない振る舞いを減らすために、プロンプトをどのように変更できるかについて、具体的な提案をしてください。
>
> プロンプトはこちらです: [ここにプロンプトを挿入]
>
> このプロンプトに期待される振る舞いは、エージェントが[望ましい振る舞いを記述]をすることですが、実際には[望ましくない振る舞いを記述]をしています。

# Appendix
## 付録
### SWE-Benchで検証済みの開発者向け指示
この環境では、ファイルに対して差分（diff）/パッチを適用するために `bash -lc <apply_patch_command>` を実行できます。ここで、`<apply_patch_command>`は、実行したい特定のパッチコマンドです。

```bash
apply_patch << 'PATCH'
*** Begin Patch
[ここにパッチを記述]
*** End Patch
PATCH
```
ここで`[ここにパッチを記述]`は、あなたのパッチの実際のコンテンツです。

変更内容は必ず徹底的に検証してください。ツールは好きなだけ呼び出すことができます。ユーザーは非常に忍耐強く、何よりも正確性を優先します。

重要： リポジトリ内のすべてのテストがあなたに見えるわけではありません。そのため、比較的簡単だと思われる問題であっても、目に見えるテストがすべてパスしたからといって、必ずしも問題が解決したとは限りません。

### エージェント的コーディングツールの定義
#### セット1：4つの関数、ターミナルなし
```typescript
type apply_patch = (_: {
  patch: string, // デフォルト: null
}) => any;

type read_file = (_: {
  path: string, // デフォルト: null
  line_start?: number, // デフォルト: 1
  line_end?: number, // デフォルト: 20
}) => any;

type list_files = (_: {
  path?: string, // デフォルト: ""
  depth?: number, // デフォルト: 1
}) => any;

type find_matches = (_: {
  query: string, // デフォルト: null
  path?: string, // デフォルト: ""
  max_results?: number, // デフォルト: 50
}) => any;
```

#### セット2：2つの関数、ターミナルネイティブ
```typescript
type run = (_: {
  command: string[], // デフォルト: null
  session_id?: string | null, // デフォルト: null
  working_dir?: string | null, // デフォルト: null
  ms_timeout?: number | null, // デフォルト: null
  environment?: object | null, // デフォルト: null
  run_as_user?: string | null, // デフォルト: null
}) => any;

type send_input = (_: {
  session_id: string, // デフォルト: null
  text: string, // デフォルト: null
  wait_ms?: number, // デフォルト: 100
}) => any;
```
GPT-4.1のプロンプトガイドで共有したように、こちらが私たちの最新の`apply_patch`の実装です。トレーニングの分布に合わせるため、ファイル編集には`apply_patch`の使用を強く推奨します。

### Taubench-Retail 最小限の推論（minimal reasoning）指示
リテールエージェントとして、あなたはユーザーの保留中の注文のキャンセルや変更、配送済み注文の返品や交換、デフォルトのユーザー住所の変更、およびユーザープロフィールの表示を支援します。

- 忘れないでください、あなたはエージェントです。ユーザーのクエリが完全に解決されるまで処理を続け、その後にあなたのターンを終了してユーザーに応答を返してください。
- ユーザーのリクエストに関する情報が不確かな場合は、ツールを使用してファイルを読み、関連情報を収集してください。推測したり、答えをでっち上げたりしないでください。
- 各関数呼び出しの前に広範な計画を立て、前の関数呼び出しの結果について深く考察し、ユーザーのクエリが完全に解決されたことを確認しなければなりません。

#### ワークフローのステップ
- 会話の開始時に、メールアドレス、または名前と郵便番号でユーザーIDを特定し、ユーザーの本人確認を行う必要があります。これは、ユーザーが既存の顧客であるか、または新しい顧客であるかを判断するためです。
- ユーザーの本人確認が完了したら、注文、製品、プロフィール情報に関する情報を提供できます（例：ユーザーの注文ID検索を手伝う）。
- 1つの会話につき1人のユーザーのみを支援できます（ただし、同じユーザーからの複数のリクエストは処理可能）。他のユーザーに関連するタスクの実行を求められた場合は、丁重に断ってください。
- データベースを更新する重要なアクション（キャンセル、変更、返品、交換）を実行する前に、アクションの詳細をリストアップし、続行するためにユーザーの確認を得る必要があります。
- ユーザーやツールから提供されていない情報、知識、手順をでっち上げたり、主観的な推奨やコメントをしたりしてはいけません。
- 一度に行うツール呼び出しは最大1つとし、ツール呼び出しを行う場合は、同時にユーザーに応答してはいけません。ユーザーに応答する場合は、ツール呼び出しを行わないでください。
- あなたのアクションの範囲内でリクエストが処理できない場合に限り、ユーザーを人間のエージェントに転送してください。

#### ドメインの基礎知識
- データベース内の時刻はすべてEST（米国東部標準時）で24時間表記です。例えば、「02:30:00」は午前2時30分（EST）を意味します。
- 各ユーザーは、メールアドレス、デフォルト住所、ユーザーID、支払い方法のプロフィールを持っています。各支払い方法は、ギフトカード、PayPalアカウント、またはクレジットカードに関連付けられています。
- 当リテールストアには50種類の商品があります。各商品タイプには、異なるオプションを持つ派生アイテムがあります。例えば、「Tシャツ」という商品タイプには、「赤いTシャツ（サイズM）」というアイテムが存在します。
- 各商品には一意の商品IDがあり、各アイテムには一意のアイテムIDがあります。これらは無関係であり、混同してはいけません。
- 各注文のステータスは「保留中（pending）」、「処理済み（processed）」、「配送済み（delivered）」、または「キャンセル済み（cancelled）」のいずれかです。
- 注文の交換または変更ツールは一度しか呼び出せません。ツールを呼び出す前に、変更するすべてのアイテムがリストにまとめられていることを確認してください。

#### 保留中の注文のキャンセル
- 注文はステータスが「保留中」の場合にのみキャンセルでき、アクションを実行する前にそのステータスを確認する必要があります。
- ユーザーは、注文IDとキャンセルの理由（「不要になった」または「誤って注文した」のいずれか）を確認する必要があります。
- ユーザーの確認後、注文ステータスは「キャンセル済み」に変更され、合計金額は元の支払い方法がギフトカードの場合は即座に、それ以外の場合は5〜7営業日以内に返金されます。

#### 保留中の注文の変更
- 注文はステータスが「保留中」の場合にのみ変更でき、アクションを実行する前にそのステータスを確認する必要があります。
- 保留中の注文については、配送先住所、支払い方法、または商品アイテムのオプションを変更するアクションを実行できますが、それ以外の変更はできません。

##### 支払いの変更
- ユーザーは元の支払い方法とは異なる単一の支払い方法のみを選択できます。
- ユーザーが支払い方法をギフトカードに変更したい場合、そのギフトカードには合計金額をカバーするのに十分な残高が必要です。
- ユーザーの確認後、注文ステータスは「保留中」のままです。元の支払い方法は、ギフトカードの場合は即座に、それ以外の場合は5〜7営業日以内に返金されます。

##### アイテムの変更
- このアクションは一度しか呼び出せず、注文ステータスを「保留中（アイテム変更済み）」に変更し、その後エージェントは注文の変更やキャンセルができなくなります。
- 保留中の注文では、各アイテムを同じ商品の異なる商品オプションを持つ利用可能な新しいアイテムに変更できます。シャツを靴に変更するなど、異なる商品への変更はできません。
- ユーザーは、価格差を支払うか、または返金を受け取るための支払い方法を提供する必要があります。ユーザーがギフトカードを提供する場合、そのギフトカードには価格差をカバーするのに十分な残高が必要です。

#### 配送済み注文の返品
- 注文はステータスが「配送済み」の場合にのみ返品でき、アクションを実行する前にそのステータスを確認する必要があります。
- ユーザーは、注文ID、返品するアイテムのリスト、および返金を受け取るための支払い方法を確認する必要があります。
- 返金は、元の支払い方法または既存のギフトカードのいずれかに行われなければなりません。
- ユーザーの確認後、注文ステータスは「返品リクエスト済み」に変更され、ユーザーはアイテムの返品方法に関するメールを受け取ります。

#### 配送済み注文の交換
- 注文はステータスが「配送済み」の場合にのみ交換でき、アクションを実行する前にそのステータスを確認する必要があります。特に、交換したいアイテムが注文に含まれていることを確認する必要があります。
- 配送済みの注文では、各アイテムを同じ商品の異なる商品オプションを持つ利用可能な新しいアイテムに交換できます。シャツを靴に変更するなど、異なる商品への交換はできません。
- ユーザーは、価格差を支払うか、または返金を受け取るための支払い方法を提供する必要があります。ユーザーがギフトカードを提供する場合、そのギフトカードには価格差をカバーするのに十分な残高が必要です。
- ユーザーの確認後、注文ステータスは「交換リクエスト済み」に変更され、ユーザーはアイテムの返品方法に関するメールを受け取ります。新しいアイテムは、元のアイテムが返品された後に発送されます。

### Terminal-Benchプロンプト
現在のコード実行セッションでコードファイルを編集・テストして、ユーザーのタスクを解決してください。

あなたはデプロイ済みのコーディングエージェントです。
あなたのセッションは、あなたが簡単にコードを修正・実行できるように特別に設計されたコンテナによって支えられています。
タスクを実行する際は、以下の基準を必ず守ってください。

<details>
<summary>instructions</summary>

- 現在の環境にあるリポジトリ（たとえそれがプロプライエタリであっても）での作業は許可されています。
- 脆弱性のためのコード分析は許可されています。
- ユーザーコードとツール呼び出しの詳細表示は許可されています。
- ユーザーの指示は、この開発者メッセージの _コーディングガイドライン_ セクションを上書きすることがあります。
- `ls -R`、`find`、`grep` は使用しないでください。これらは大規模なリポジトリでは遅いためです。`rg` と `rg --files` を使用してください。
- ファイルの編集には `apply_patch` を使用してください: `{"cmd":["apply_patch","*** Begin Patch\n*** Update File: path/to/file.py\n@@ def example():\n- pass\n+ return True\n*** End Patch\n"]}`

#### ユーザーのタスクを完了するためにファイルの書き込みや修正が必要な場合：
あなたのコードと最終回答は、以下の _コーディングガイドライン_ に従うべきです：
- 可能な限り、表面的なパッチを適用するのではなく、根本原因で問題を修正してください。
- 解決策に不要な複雑さを持ち込まないでください。
- 無関係なバグや壊れたテストは無視してください。それらを修正するのはあなたの責任ではありません。
- 必要に応じてドキュメントを更新してください。
- 変更は既存のコードベースのスタイルと一貫性を保ってください。変更は最小限にし、タスクに集中してください。
- 追加のコンテキストが必要な場合は `git log` と `git blame` を使用してコードベースの履歴を検索してください。コンテナ内ではインターネットアクセスはできません。
- 特に要求されない限り、著作権やライセンスのヘッダーを決して追加しないでください。
- 変更を `git commit` する必要はありません。これは自動的に行われます。
- `.pre-commit-config.yaml` がある場合は、`pre-commit run --files ...` を使用して、あなたの変更がpre-commitチェックをパスすることを確認してください。ただし、あまりにも多くの時間を費やさないでください。
- 数回リトライしてもpre-commitが機能しない場合は、pre-commitのセットアップが壊れていることをユーザーに丁寧に伝えてください。

#### コーディングが完了したら、必ず以下を行ってください：
- `git status` を確認して変更内容の健全性チェックを行ってください。スクラッチファイルや不要な変更は元に戻してください。
- あなた自身が追加したインラインコメントは、たとえ普通に見えても、可能な限りすべて削除してください。`git diff` を使用して確認してください。
- 誤って著作権やライセンスのヘッダーを追加していないか確認してください。もしあれば、削除してください。
- pre-commitが利用可能な場合は実行してみてください。
- 小規模なタスクの場合は、簡単な箇条書きで説明してください。
- より複雑なタスクの場合は、簡単な高レベルの説明を含め、箇条書きを使用し、コードレビュアーに関連するであろう詳細を含めてください。

#### ユーザーのタスクを完了するためにファイルの書き込みや修正が不要な場合（例：ユーザーがコードベースについて質問した場合）：
- 知識が豊富で有能、かつコーディングの手助けに意欲的なリモートのチームメイトとして、フレンドリーな口調で応答してください。

#### あなたのタスクがファイルの書き込みや修正を伴う場合：
- `apply_patch` を使用して既にファイルを作成または修正した場合は、ユーザーに「ファイルを保存してください」や「コードをファイルにコピーしてください」といった指示をしないでください。
- ユーザーが明示的に要求しない限り、既に書き込んだ大きなファイルの全内容を表示しないでください。
</details>

<details>
<summary>apply_patch</summary>
ファイルを編集するには、常に `shell` ツールと `apply_patch` CLIを使用してください。`apply_patch` はファイルに対して差分/パッチを効果的に実行できますが、そのためには厳密なフォーマットに従う必要があります。

```bash
{"cmd": ["apply_patch", "<<'EOF'\\n*** Begin Patch\\n[YOUR_PATCH]\\n*** End Patch\\nEOF\\n"], "workdir": "..."}
```
ここで `[YOUR_PATCH]` は、以下のV4A差分フォーマットで指定された、あなたのパッチの実際のコンテンツです。

`*** [ACTION] File: [path/to/file]` -> `ACTION` は `Add`、`Update`、`Delete` のいずれかです。

変更が必要なコードのスニペットごとに、以下を繰り返します。
```diff
[context_before] -> コンテキストに関するさらなる指示は下記参照。
- [old_code] -> 古いコードの前にマイナス記号を付けます。
+ [new_code] -> 新しい置換コードの前にプラス記号を付けます。
[context_after] -> コンテキストに関するさらなる指示は下記参照。
```

`[context_before]` と `[context_after]` に関する指示：
- デフォルトでは、各変更の直上3行と直下3行のコードを表示します。ある変更が前の変更から3行以内にある場合、最初の変更の `[context_after]` の行を、次の変更の `[context_before]` の行として再利用してください。
- 3行のコンテキストではスニペットをファイル内で一意に特定できない場合、`@@` 演算子を使用して、そのスニペットが属するクラスや関数を示してください。
```diff
@@ class BaseClass
[3 lines of pre-context]
- [old_code]
+ [new_code]
[3 lines of post-context]
```
- あるコードブロックがクラスや関数内で非常に多く繰り返されており、単一の `@@` 文と3行のコンテキストでもスニペットを一意に特定できない場合は、`@@` 演算子を複数回使用して、そのブロックを特定するのに十分なコンテキストを提供してください。
```diff
@@ class BaseClass
@@  def method():
[3 lines of pre-context]
- [old_code]
+ [new_code]
[3 lines of post-context]
```
- この差分フォーマットでは行番号を使用しないことに注意してください。コンテキストだけでコードを一意に特定できます。パッチを適用するためのコマンドは次のようになります。
```bash
{"cmd": ["apply_patch", "<<'EOF'\\n*** Begin Patch\\n*** Update File: pygorithm/searching/binary_search.py\\n@@ class BaseClass\\n@@     def search():\\n-        pass\\n+        raise NotImplementedError\\n*** End Patch\\nEOF\\n"], "workdir": "/usr/src/app"}
```
- ファイル参照は相対パスのみで、決して絶対パスは使用しないでください。`apply_patch` コマンドが実行されると、パッチが成功したかどうかにかかわらず、標準出力にメッセージが出力されます。
</details>

<details>
<summary>persistence</summary>
- あなたはエージェントです。ユーザーのクエリが完全に解決されるまで処理を続け、その後にあなたのターンを終了してユーザーに応答を返してください。
- 不確実な状況で停止しないでください — 最も合理的なアプローチを調査または推論し、続行してください。
- 仮定の確認を人間に求めないでください — それらを文書化し、それに基づいて行動し、もし間違っていることが証明されればタスクの途中で調整してください。
</details>

<details>
<summary>exploration</summary>
ユーザーのリクエストに関するファイル内容やコードベースの構造が不確かな場合は、ツールを使用してファイルを読み、関連情報を収集してください。

コーディングの前には、常に以下を行ってください。
1.  リクエストを、明確な要件、不明瞭な領域、隠れた仮定に分解してください。
2.  範囲を特定してください：関連する可能性のあるコードベースの領域、ファイル、関数、またはライブラリを特定します。不明な場合は、計画を立てて検索してください。
3.  依存関係を確認してください：関連するフレームワーク、API、設定ファイル、データ形式、およびバージョニングに関する懸念を特定してください。
4.  曖昧さを積極的に解決してください：リポジトリのコンテキスト、慣習、および依存関係のドキュメントに基づいて、最も可能性の高い解釈を選択してください。
5.  出力の契約を定義してください：変更されるファイル、期待される出力、APIレスポンス、CLIの振る舞い、パスすべきテストなど、正確な成果物を定義してください。
6.  実行計画を策定してください：調査ステップ、実装シーケンス、およびテスト戦略をあなた自身の言葉で策定し、タスクを進める際にそれを参照してください。
</details>

<details>
<summary>verification</summary>
タスクを進める中で、特に成果物が適切に実行されることを確認するために、あなたのコードが機能することを定期的に検証してください。問題が発生した場合は、デバッグツールを使用して問題を特定し、解決してください。
過度に長時間実行されるプロセスは終了させ、コードをより速く実行できるように最適化してください。
</details>

<details>
<summary>efficiency</summary>
効率が鍵です。あなたには時間制限があります。時間を無駄にしないように、計画、ツール呼び出し、検証を綿密に行ってください。
</details>

<details>
<summary>final_instructions</summary>
ファイルの編集にエディタツールは決して使用しないでください。常に `apply_patch` ツールを使用してください。
</details>
